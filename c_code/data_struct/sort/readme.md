## 排序

排序是计算机系统中一个重要的功能, 它的目的是将一组数据元素的任意序列, 重新排序成一个按关键字有序的序列.

每次排序的结果要么是从小到大，要么就是从大到小. 在一组排序的数据里面, 很可能拥有相同关键字的, 以此, 根据排序的结果, 我们对排序的方法有两个判断:

- `排序方法稳定`: 排序后两个或多个相同的数据元素的位置和排序前的位置保持相对不变则称之为稳定排序
- `不稳定排序方法`: 排序后的两个或多个相同数据元素位置改变则称之为不稳定排序.

> 例如: 对于这样的一组数据 `49 38 65 97 76 13  27 49`.  根据下标, 如果第0位的49排序后还在第7位的49之前那么排序方法就是稳定的,反之就是不稳定的.

从排序的数据量上来分类, 我们可以将排序算法分为`内部排序`和`外部排序`.

- `内部排序`: 一般来说可以直接在内存中排序完成的过程称之为内部排序
- `外部排序`: 数据量较大,不能一次性在内存中排序完成,需要借助外部存储(磁盘)参与的过程称之为外部排序.


衡量一个排序算法的好坏主要是看算法所占用的 `时间复杂度` 和 `空间复杂度`, 原则上一个算法在 `时间` 和 `空间` 上都花费较少我们就说是一个好的算法.

根据现在的算法对比, **时间复杂度** 主要有O(n^2), O(nlogN).

基于时间复杂度对算法的划分:

- `O(N^2)`: 冒泡排序, 插入排序

#### 思路

通常在排序的过程中,需要对元素做两个基本的操作: 
1. 比较两个关键字的大小
2. 将一个记录从某个位置移动到另一个位置


## 插入排序

#### 直接插入排序

直接插入排序是最简单的一种排序算法, 它的基本思想是把数据插入到一个已经排序好的有序数据之中. 例如对于这样的一组数据 `49 38 65 97 76 13  27 49`:

第一步: 我们认为 `49` 是一个已经排序好的数列, 现在需要将 `38` 插入到这个数列中, 便得到以下数列: `38`, `49`.

第二步：我们要把 `65` 插入到数列: `38`, `49` 中, 只需要比较数列的最后一个元素即可, 因为最后一个(`49`)也小于`65`,所以不需要交换。

第三步: 以此类推, 最后一个`65`也小于`97`, 所以也不需要交换, 目前得到一下数列: `38`, `49`, `65`, `97`.

第四步: 需要将`13`插入到上述数列, 首先, 将`13`和`97`比较并移动位置得到以下数列: `38`, `49`, `65`, `13`, `97`. 同理将 `13` 和 `65` 比较, 以此类推. 最后得到数列: `13`, `38`, `49`, `65`, `97`.

...

以此类推.

从上述流程可以看出, 我们需要使用两个`for` 循环, 第一个 `for` 循环用于遍历后面的所有元素, 第二个`for` 循环用于向前面已经排序好的数列遍历, 找到合适的位置将要排序的数据插入.

具体代理可以参考: [C 插入排序](./insertsort.c)


#### 折半插入排序

从上述可以看到, 对于数据量比较少的情况下, 直接插入排序确实很快, 但当数据量很大时,我们可以利用前面的数列是一个已经排序好的数据这一特性, 使用折半查找来确定要插入的位置.

代码请参考: [折半插入排序](./halfinsertsort.c)


从代码中可以看出来, 折半查找并没有减少数据的移动次数, 只是减少了数据的比较次数, 但也算是一种优化.

#### 二路插入排序

为了减少数据移动的次数, 我们引用了二路插入排序. 但此算法会引用一个额外的存储空间, 因此将使用**空间复杂度**换**时间复杂度**.

具体的算法如下:

1. 引用一个和待排序数列相等类型的结构(T), 并附设头尾(head, tail)指针指向该结构的第0个位置.
2. 将待排序第一个数据插入到T中, 此时将其看做中间元素, 后面的数据根据大小依次插入到中间元素前后.
3. 插入中间元素之前我们移动head指针, 插入中间元素之后我们移动tail指针, 注意: 改结构T此时是一个循环数组, 要以取模来确定头尾指针的位置.
4. 当要插入的元素既不比头指针指向的元素小, 也不比尾指针指向的元素大, 此时就需要移动位置来确定元素的插入.

算法如下: [二路插入排序](./twayinsertsort.c)

从代码中可以看出, 二路插序只能够减少数据的移动的次数, 不能完全避免数据的移动. 而且对于第一个数据的选择尤为重要, 如果我们恰好选择了一个最小值作为二路插序的第一个元素, 那么二路插序的算法将会退化为直接插入排序.

以上的数列都是基于数组进行展示的, 我们知道数组是一个容易查找, 但是不容易插入的数据结构, 所以在实际中我们可以将此数列以链表的方式作为底层的数据结构.

#### 表插入排序

TODO: 后续补全

#### 希尔排序

我们知道直接插入排序在一个数列基本有序的情况下会大幅度的减少数据的移动次数和比较次数, 如过我们同过优化可以将一个数列提前做到基本有序, 那么将直接降低排序的时间复杂度. 希尔排序就是一个`缩小增量`的算法, 这里以 `49 38 65 97 76 13 27 49` 数列, 增量为 `3 2 1`举例. 它的基本思想如下:

1. 首先, 以 `3` 的增量来比较, 对子数列: `49 97 27` 进行插入排序, 排序好的数列为:`27 38 65 49 76 13 97 49`.
2. 之后, 在以 `2` 的增量进行排序, 对子数列 `27 65 76 97` 进行插入排序, 可以看到已经是有序的了.
3. 之后, 在以 `1` 的增量进行排序, 也就是最开讲的直接插入排序. 便可以得到对应的排序数列.

具体的算法参考: [希尔排序](./shellsort.c)

在实际中, 一个好的增量序列可以让程序的效率更高, 很可以目前还没有一个完整的理论得出什么样的增量是最好的, 开发可自行处理.

## 冒泡排序

## 快速排序

## 堆排序