## 排序

排序是计算机系统中一个重要的功能, 它的目的是将一组数据元素的任意序列, 重新排序成一个按关键字有序的序列.

每次排序的结果要么是从小到大，要么就是从大到小. 在一组排序的数据里面, 很可能拥有相同关键字的, 以此, 根据排序的结果, 我们对排序的方法有两个判断:

- `排序方法稳定`: 排序后两个或多个相同的数据元素的位置和排序前的位置保持相对不变则称之为稳定排序
- `不稳定排序方法`: 排序后的两个或多个相同数据元素位置改变则称之为不稳定排序.

> 例如: 对于这样的一组数据 `49 38 65 97 76 13  27 49`.  根据下标, 如果第0位的49排序后还在第7位的49之前那么排序方法就是稳定的,反之就是不稳定的.

从排序的数据量上来分类, 我们可以将排序算法分为`内部排序`和`外部排序`.

- `内部排序`: 一般来说可以直接在内存中排序完成的过程称之为内部排序
- `外部排序`: 数据量较大,不能一次性在内存中排序完成,需要借助外部存储(磁盘)参与的过程称之为外部排序.


衡量一个排序算法的好坏主要是看算法所占用的 `时间复杂度` 和 `空间复杂度`, 原则上一个算法在 `时间` 和 `空间` 上都花费较少我们就说是一个好的算法.

根据现在的算法对比, **时间复杂度** 主要有O(n^2), O(nlogN).

基于时间复杂度对算法的划分:

- `O(N^2)`: 冒泡排序, 插入排序

#### 思路

通常在排序的过程中,需要对元素做两个基本的操作: 
1. 比较两个关键字的大小
2. 将一个记录从某个位置移动到另一个位置


## 插入排序

#### 直接插入排序

直接插入排序是最简单的一种排序算法, 它的基本思想是把数据插入到一个已经排序好的有序数据之中. 例如对于这样的一组数据 `49 38 65 97 76 13  27 49`:

第一步: 我们认为 `49` 是一个已经排序好的数列, 现在需要将 `38` 插入到这个数列中, 便得到以下数列: `38`, `49`.

第二步：我们要把 `65` 插入到数列: `38`, `49` 中, 只需要比较数列的最后一个元素即可, 因为最后一个(`49`)也小于`65`,所以不需要交换。

第三步: 以此类推, 最后一个`65`也小于`97`, 所以也不需要交换, 目前得到一下数列: `38`, `49`, `65`, `97`.

第四步: 需要将`13`插入到上述数列, 首先, 将`13`和`97`比较并移动位置得到以下数列: `38`, `49`, `65`, `13`, `97`. 同理将 `13` 和 `65` 比较, 以此类推. 最后得到数列: `13`, `38`, `49`, `65`, `97`.

...

以此类推.

从上述流程可以看出, 我们需要使用两个`for` 循环, 第一个 `for` 循环用于遍历后面的所有元素, 第二个`for` 循环用于向前面已经排序好的数列遍历, 找到合适的位置将要排序的数据插入.

具体代理可以参考: [C 插入排序](./insertsort.c)


#### 折半插入排序

从上述可以看到, 对于数据量比较少的情况下, 直接插入排序确实很快, 但当数据量很大时,我们可以利用前面的数列是一个已经排序好的数据这一特性, 使用折半查找来确定要插入的位置.

代码请参考: [折半插入排序](./halfinsertsort.c)


从代码中可以看出来, 折半查找并没有减少数据的移动次数, 只是减少了数据的比较次数, 但也算是一种优化.


## 冒泡排序

## 快速排序

## 堆排序